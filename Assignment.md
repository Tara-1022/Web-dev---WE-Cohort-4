#08-03-24

I would like you to prepare a document with the following:

- 5 non-trivial defenses of the waterfall model (250 words)
- A brief history of the agile movement and the agile manifesto (250 words)
- A brief history of eXtreme Programming and its core ideas (250 words)
- The ideas that make up DelOps (250 words)
# 5 non-trivial defenses of the waterfall model

Let's firstly define the waterfall model - 'a breakdown of development activities into linear sequential phases, ... where each phase depends on the deliverable of the previous one and corresponds to the specialisation of tasks.' This models a flow of operations that follow a fairly rigid structure, where - depending on the definition - the developers may not move back to a previous stage, flowing downwards like a waterfall. 
The first defense - a key feature of the model is that it formalizes the fundamental steps that must be a part of any good engineering process. That is, it serves as a starting-point by which to judge an organisation's process and task flow. An organisation would be handling things extremely irresponsibly if it did not have these steps in some form or another.
Secondly - the model lays out clearly the sequence of operations to be followed - while it may seem fairly obvious that design must precede code, it may not be so obvious in all situations. Having a clear model gives rise to better planning, and clarity of action.
Thirdly, the operations are conveniently sequenced in order of increasing cost of fixing bugs that arise during the corresponding stage. It serves as a checkpoint to see if one has truly, really satisfied the requirements of one stage before moving to the next. While it is to be contested whether testing only after development is complete is the right course of action, it cannot be denied that there is little point in getting deep into development without having a clear design in mind.
Fourth - It advocates for the specialisation of tasks. This leads to better planning as to who should do what, and when, so that the stages are completed satisfiably. There is a definite need to be able to allocate the right types of people and the right approaches to a given task. Keeping in mind that 'Requirements specification' is a different domain from 'Development' keeps the division of responsibilities clear and lets each person follow up their responsibilities, and do it well.
Finally - A model is a definite, agreed-on definition of processes. These are important to have for the purposes of communication - no matter how primitive or simplistic these models may be. Having such tools allows us to arbitrate on the efficacy of the processes they represent, and raise discussions on how things can be done better. Formalised models allow us to have better, nuanced discussions of what works for a development team.


# A brief history of the agile movement and the agile manifesto

In the late 90's (and early 2000's), a number of lightweight software development methods evolved in reaction to the prevailing heavyweight ones. These heavyweight methods - generalised as 'waterfall methods' were a product of highly bureaucratic, organisational, outcome- and deadline-focused process systems that were overly regulated, planned and micromanaged. The Agile movement was, in effect, a response to the highly process-oriented structures that were followed by such organisations. The movement seeked to bring back focus to the actual engineers, with people-forward processes that lead to quality software. That is, ''about delivering good products to customers by operating in an environment that does more than talk about "people as our most important asset" but actually "acts" as if people were the most important, and lose the word "asset"."
As per the history of the Agile Manifesto - a document outlining key values and principles of the newly compiled software development methodology, written in collaboration by 'the Agile Alliance' - the movement outlines certain principles in protest to he prevailing documentation-driven, corporate-imposed devleopment processes.
The Manifesto, signed by all seventeen participants who convened in February, 2001, outlines the core values behind the movement - Individuals and interactions over processes and tools, Working software over comprehensive documentation, Customer collaboration over contract negotiation, Responding to change over following a plan.
The manifesto also outlines 12 principles that form the backbone of ideal Agile processes.
# A brief history of eXtreme Programming and its core ideas

Extreme Programming (short, XP) is a software development methodology that originated in the late 1990s and was championed by Kent Beck, Ward Cunningham, and other industry experts. It was developed as a response to the perceived limitations of traditional software development approaches such as Waterfall, which often led to delayed deliveries, exceeded budgets, and unsatisfactory end products. XP places a strong emphasis on adaptability, effective communication, and customer satisfaction. The core principles of XP include the following.
Continuous Feedback: XP places great importance on involving the customer throughout the development process and obtaining their feedback regularly. This enables developers to quickly adapt to changing requirements and ensures that the final product meets the customer's needs.
Iterative Development: XP advocates for breaking down the development process into small, manageable increments. These increments are delivered frequently, allowing for early testing and validation of features. This approach reduces the risk of encountering major errors in the later stages of development. 
Simplicity: XP encourages developers to keep the design and implementation of the software as simple as possible. This involves avoiding unnecessary complexity and focusing on delivering the most valuable features first. 
Pair Programming: XP promotes the practice of developers working in pairs, with one person writing the code while the other reviews it in real-time. This collaborative approach fosters knowledge sharing, improves code quality, and enhances overall team collaboration. 
Test-Driven Development (TDD): In XP, tests are written before the code is implemented. This ensures that the code meets the desired specifications and remains functional even after future modifications. 
Continuous Integration: XP advocates for frequent integration of code changes into a shared repository, coupled with automated build and testing processes. This approach reduces integration issues and allows for early detection of defects. 
On-site Customer: XP emphasizes the importance of having a dedicated customer representative closely involved in the development process. This helps clarify requirements, address any concerns or questions, and ensures that the final product aligns with the customer's expectations. 
Extreme Programming prioritizes agility, adaptability, and close collaboration with the customer. This makes it a well-suited methodology for software development projects.

# The ideas that make up DevOps

DevOps is a methodology for software development, that is used as practices and tools to automated software development and IT operations.
It was developed over the course of several years, as concerns began to be raised over the fact that software development and IT industries were treated as entirely separate, leading to dysfunction in the industry.
The fundamental ideas of DevOps practices draw from existing ideas from Lean, Plan-Do-Check-Act cycle, The Toyota Way, and the Agile approach. The key ideas include:
Core ideas behind DevOps include
**Automation of the software development lifecycle.** - reduce time and effort spent on repetitive, repeating and manual tasks such as testing, building and releasing
**Collaboration and communication.** - the best software comes from motivated teams, and face-to-face communication is key to reliable, quality development
**Continuous improvement and minimization of waste.** - improve on all areas that can be improves - both in the product and in the development or communication cycle itself.
**Hyperfocus on user needs with short feedback loops.** - having regained attention from manual tasks, the focus can be brought back to the core of the development process - which is meeting the needs of real users.